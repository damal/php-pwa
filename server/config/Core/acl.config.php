<?php
/*
======================================================================================
	Файл: acl.config.php
	Описание: Настройки Access Control List
	Разработано (с) 2012 svtretyakov
======================================================================================
*/

/*--------------------------------------------------------------------------------------
Настройки Access Control List
--------------------------------------------------------------------------------------*/
return array(

	#Основные настройки ACL
	'db_link'			=> 'main',								#(*) Текстовое наименование соединения с базой данных: получение списка ACL объектов
	'access_timeout'	=> 1800,								#Интервал обновления прав доступа пользователя, работающего в рамках одной сессии
	'error_level'		=> 2,									#Уровень обработки ошибок, не может быть больше чем CORE_MAX_ERROR_LEVEL
	'admin_role'		=> 1,									#Идентификатор роли, которой назначаются все права во всех организациях - суперпользователь (администратор)
	'developer_role'	=> 2,									#Идентификатор роли разработчика: если пользователь имеет доступ к объекту с указанным ID, то блокировка объектов для него не выполняется
	'ignore_hash_check'	=> false,								#Признак игнорирования проверки хеш сумм при аутентификации и авторизации пользователей, а также прав доступа в сессии
	'ignore_hash_error'	=> false,								#Признак игнорирования ошибок хеш сумм при аутентификации и авторизации пользователей, а также прав доступа в сессии
	'sess_priv_rsa'		=> 'sha1',								#Сертификат для расчета контрольной суммы прав доступа для сессии пользователя (по-умолчанию, sha1)

	#Дополнительные объекты, применяемые в системе логирования
	#Массив должен пополняться соответствующими типами объектов в зависимости от построения бизнес-логики приложения
	#Каждая запись массива представляет собой также массив, структура записи массива:
	#array(type_id, type_desc, type_applied);
	#type_id - числовой идентификатор типа объекта
	#type_desc - понятное наименование типа объекта
	#type_applied - применимость объекта: 0 - нигде не используется, 1 - только для протоколирования и работы с протоколами, 2 - для протоколирования + для сознаия ACL объектов данного типа
	'objects' 			=> array(

		#Системные объекты ACL
		'undefined'		=> array(ACL_OBJECT_UNDEFINED,'Не определен', 0),		#Тип объекта не определен
		'page'			=> array(ACL_OBJECT_PAGE,'Страница', 2),				#Объект доступа типа страница
		'function'		=> array(ACL_OBJECT_FUNCTION,'Функция', 2),				#Объект доступа типа функция
		'role'			=> array(ACL_OBJECT_ROLE,'Роль', 2),					#Объект доступа типа роль
		'internal'		=> array(ACL_OBJECT_INTERNAL,'Внутренний объект', 2),	#Объект Внутренний абстрактный объект
		'report'		=> array(ACL_OBJECT_REPORT,'Отчет', 2),					#Объект Отчет

		#Дополнительные системные ACL объекты
		'group'			=> array(ACL_OBJECT_GROUP,'Группа Acl', 1),			#Объект Группа безопасности Acl
		'company'		=> array(ACL_OBJECT_COMPANY,'Организация', 1),		#Объект Организация

		#Навигационное меню
		'pagegroup'		=> array(101,'Раздел меню', 1),			#Объект доступа типа группа страниц

		#Отчеты
		'reportgroup'	=> array(201,'Группа отчетов', 1),		#Объект Группа отчетов
		'reportsection'	=> array(202,'Секция отчетов', 1)		#Объект Секция отчета

	),


	#Источники данных ACL
	#Под "источником данных" понимается некий набор настроек, правил, непосредственно таблиц базы данны и полей таблиц
	#откуда следует аутентифицировать пользователя и брать права для его доступа
	#Например, менеджеры и клиенты заходят на ресурс через один web-интерфейс, одно web-приложение, но разные типы пользователей.
	#Поскольку обычно информация об учетных записях менеджеров и клиентов хранится в разных таблицах БД или даже в разных БД
	#а также требуется основательное разграничение прав доступа между клиентами и менеджерами, объединить в одном месте такие типы
	#пользователей не представляется возможным или по-крайней мере очень затруднительно.
	#В ACL для этого применяется универсальный механизм источников данных, позволяющий аутентифицировать и наделять правами
	#любых пользователей (клиентов, менеджеров, администраторов  и т.п.) правами доступа и разграничивать их функциональные возможности
	'sources'			=> array(

		'main' => array(

			#Основные настройки
			'name'			=> 'Пользователи из acl_users', #(*) Понятное название источника данных
			'active'		=> true,	#(*) Признак активности источника данных, если FALSE - аутентификация пользователей из источника данных проводиться не будет
			'acl_subject'	=> array(ACL_SUBJECT_USER, ACL_SUBJECT_DEVELOPER, ACL_SUBJECT_ADMIN),	#(*) Из данной таблицы может быть аутентифицирован ТОЛЬКО пользователь, разработчик или администратор

			#Настройки источника данных
			'db_link'		=> null,										#(*) Текстовое наименование соединения с базой данных, если не задана, используется основная ссылка $this->options['db_link']
			'table_info'	=> null,										#Таблица базы данных с дополнительной информацией по пользователю, если null - дополнительная информация не грузится
			'table_auth'	=> 'acl_users',									#(*) Таблица базы данных с аутентификационной информацией пользователей

			#Поля таблицы аутентификации пользователей
			'field_auth_id'				=> 'user_id',								#(*) Поле таблицы, в котором хранится идентификатор пользователя
			'field_auth_login'			=> 'login',									#(*) Поле таблицы, в котором хранится имя пользователя
			'field_auth_pass'			=> 'password',								#(*) Поле таблицы, в котором хранится пароль пользователя
			'field_auth_name'			=> 'name',									#(*) Поле таблицы, в котором хранится имя пользователя
			'field_auth_status'			=> 'status',								#Поле таблицы, в котором хранится статсу учетной записи пользователя, 0 - учетная запись заблокирована
			'field_auth_lastcompany'	=> 'last_company',							#Поле таблицы, в котором хранится последняя активная организация, с которой работал пользователь
			'field_auth_lastlogin'		=> 'last_login',							#Поле таблицы, в котором хранится datetime последней аутентификации 
			'field_auth_lastip'			=> 'last_ip',								#Поле таблицы, в котором хранится IP адрес последней аутентификации 
			'field_auth_lastupdate'		=> 'last_update',							#Поле таблицы, в котором хранится datetime последнего обновления прав доступа
			'field_auth_needupdate'		=> 'need_update',							#Поле таблицы, в котором хранится признак необходимости перегрузить права доступа пользователя

			#Роли по-умолчанию, назначаемые пользователям, если null или пустой массив - ничего не назначается
			'def_roles' => array(
				/*
				Пример записи ролей по-умолчанию:
				array(122,2,0),						#При аутентификации пользователю будет присвоена роль ID=122 в организации ID=2
				array('role.user.default',0,0)		#При аутентификации пользователю будет присвоена роль "role.user.default" (ID роли будет вычислен автоматически из ее названия) во всех организациях
				*/
			),

			#Группы доступа, по умолчанию присваемые пользователям из данного источника данных
			#Массив имеет формат линейного индексного массива со списком групп доступа, 
			#каждая запись которого представляет собой массив вида array(group_name, restrict);
			'def_groups' => array(
				/*
				 Пример записи:
				 'test_group',
				 'admin_group'
				*/
			
			),

			/*
			 * Правила, при выполнении которых пользователям назначаются определенные права доступа или пользователь включается в какие-нибудь группы
			 * Идея "правил" состоит в том, чтобы наделить пользователя некоторыми правами, если значения атрибутов пользователя соответствуют заданным условиям
			 * аттрибутами считаются обеъединенные в единый массив поля таблиц table_auth и table_info, если она задана.
			 * Например, можно задать правило, при котором пользователь с логином 'admin' автоматически получает некую роль 'role.admin.test' и 'role.admin.test2',
			 * а также будет включен в группы: 'test1' и 'test2'
			 * Правило будет выглядеть следующим образом:
			 * 'rule_name' => array(
			 * 		'params' => array(	//Массив параметров, при успешном выполнении которых сработает правило
			 * 			array(
			 * 				'key' 		=> 'login',	# Имя поля в таблице table_auth или table_info для получения значения атрибута
			 * 				'value'		=> 'admin'	# Значение, сравниваемое со значением атрибута пользователя из поля таблицы, 
			 * 										# если значение задано массивом, тогда правило сработает если один из элементов массива 
			 * 										# соответствует значению аттрибута (аналог IN() в SQL)
			 * 				'operator'	=> 'LIKE%'	# Оператор, применяемый для выполнения сравнения, возможные операторы:
			 * 										# "="			- РАВНО, правило сработает если текстовые строки или числовые значения равны, используется по-умолчанию
			 * 										# "!=","<>"		- НЕ РАВНО, правило сработает если текстовые строки или числовые значения НЕ равны
			 * 										# ">"			- БОЛЬШЕ, правило сработает если аттрибут пользователя больше value
			 * 										# "<"			- МЕНЬШЕ, правило сработает если аттрибут пользователя меньше value
			 * 										# ">="			- БОЛЬШЕ ИЛИ РАВНО, правило сработает если аттрибут пользователя больше или равен value
			 * 										# "<="			- МЕНЬШЕ ИЛИ РАВНО, правило сработает если аттрибут пользователя меньше или равен value
			 * 										# "LIKE"		- СООТВЕТСТВУЕТ без учета регистра, сравнение текстовых значений через strcasecmp(), правило сработает если строки идентичны
			 * 										# "LIKE%"		- НАЧИНАЕТСЯ С без учета регистра, правило сработает если аттрибут пользователя начинается со значения value
			 * 										# "%LIKE"		- ЗАКАНЧИВАЕТСЯ без учета регистра, правило сработает если аттрибут пользователя заканчивается значением value
			 * 										# "%LIKE%"		- СОДЕРЖИТ без учета регистра, правило сработает если аттрибут пользователя содержит значение value
			 * 										# "CASELIKE"	- СООТВЕТСТВУЕТ с учетом регистра, сравнение текстовых значений через strcmp(), правило сработает если строки идентичны
			 * 										# "CASELIKE%"	- НАЧИНАЕТСЯ С с учетом регистра, правило сработает если аттрибут пользователя начинается со значения value
			 * 										# "%CASELIKE"	- ЗАКАНЧИВАЕТСЯ с учетом регистра, правило сработает если аттрибут пользователя заканчивается значением value
			 * 										# "%CASELIKE%"	- СОДЕРЖИТ с учетом регистра, правило сработает если аттрибут пользователя содержит значение value
			 * 			)
			 * 		),
			 * 		'roles' => array(	//Массив прав доступа, назначаемый пользователю при сработке правила
			 * 			array('role.admin.test',0),		//Объект доступа (в примере - роль) и организация (0 - все организации)
			 * 			array('role.admin.test2',0),	//Объект доступа (в примере - роль) и организация (0 - все организации)
			 * 		),
			 * 		'groups' =>array('test1','test2')	//Линейный массив названий групп, в которые будет включен пользователь
			 * )
			 * 
			 * Еще пример: для клиентов, чей пол - женский (поле sex из таблицы table_info)
			 * и клиент - физическое лицо (поле type из таблицы table_info),
			 * предоставлять доступ на страницу поздравлений в организации ID 1:
			 * 'test_rule' => array(
			 * 		'param'=>array(
			 * 			array('key'=>'sex', 'value'=>'female'),
			 * 			array('key'=>'type', 'value'=>'person')
			 * 		),
			 * 		'roles'=>array(array('page.female.holiday',1))
			 * )
			 */
			'rules' => array(

				'adm111' => array(
					'params' => array(
						array(
							'key' => 'login',
							'value' => array('admin','developer'),
							'operator' => '<>'
						)
					),
					'groups' => array(array('group.admin',1),array('group.developer',1)),
					'roles' => array(
						array('role.admin',0, 1),
						array('role.developer',0, 1)
					)
				)

			),
			#Дополнительные таблицы в базе данных, для источника данных
			'table_access'				=> 'acl_access',							#(*) Таблица базы данных с информацией о правах доступа пользователей
			'table_log'					=> 'acl_log',								#(*) Таблица базы данных, в которую следует писать протокол действий пользователя
			'table_group'				=> 'acl_user_groups'						#(*) Таблица базы данных с информацией о группах, в которые включен пользователь
		)

	),



	#Тип данных: 
	#vars - переменные, 
	#defines - константы, декларируются через define(), все переменные массива должны быть скалярными
	'__type__' => 'vars'

);#end

?>